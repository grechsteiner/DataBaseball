// "main file"
// Contains all backend APIs

//---------Headers---------//

import express from 'express'
import cors from 'cors'
import { getAllPlayers, getBatting } from './database.js'

const app = express() 

app.use(express.json()) 
app.use(cors())

//-------------------------------------//

app.use((err, req, res, next) => { // Express 5 middleware
    console.error(err.stack)
    res.status(500).send('Something broke!')
})

// ------------API's-------------------//

// URL/path: domain/people, so you can call this API by typing localhost:3000/player
app.get("/allplayers", async (req, res) => { 
    const players = await getAllPlayers(20) // placeholder constant 20
    res.send(players)
})

app.get("/leaderboard", async (req, res) => {
    const players = await getBatting(2022, 20) 
    res.send(players) // return to frontend

    // To access values from request:
    // const {year, minGames} = req.body
    // This syntax is for "destructuring", a javascript technique to extract values from an object
}) 

// Crash course on Javascript:
// In JS, you can have asynchronous code to execute "in the background" (JS is single-threaded so you won't
// have truly concurrent lines running. async indicates that code inside the function may not run one line after the other
// Declaring functions as asynchronous returns a Promise, which is an object representing the "status" of an
// async function (pending, fulfilled, rejected)
// IMPORTANT: By using "await", the program will wait until the Promise resolves or rejects, and 
// return whatever result is generated by the line using "await"
// "await" is necessary if later lines of code use data from the current line


// Add more API's here...

//---------------------------------------//

// NOTE: Implement routing for Milestone 2...?

app.listen(3001, () => {
    console.log('Server is running on port 3001')
})

